# =============================================================================
# importing external packages
from sympy import symbols, Eq, simplify, Function, Add
#from libcellml import Parser, Printer, Validator, cellmlElementTypeAsString
from colorama import Fore, Back, Style, init


# Importing internal packages
from utilities import print_model
import chebi_fetch as chf
import compound_element_sorter as ces


def equation_builder( components, printing = 'off' ):

    '''
    This function takes the components and creates reaction rate equations and concentration rate equations for the reactions and compounds, respectively
    The function can display the reaction rate, concentration rate, and boundary condition equations
    But the function returns reaction rate equations and the boundary conditions to be used in constructing the concentration rate equations being created from the stoichiometric matrix
    There is an equation printing option which can be turned on if needed
    '''

    variables = []                          # This list contains the variables of cellml file [In CellML file]

    coefficients = []                       # The difference between variables and coefficients is identified by the first part of their id which is like "va_12345_r1", first part indicates that this parameter is a variable

    reaction_rates = []                     # This list contains all the rate variables (classes) for all equations that are in the model

    reaction_rate_constants = []            # This list contains the rate constants (classes) that are in the model
    
    boundary_conditions = []                # This list stores the boundary condition variables (classes) defined by the user

    reaction_rate_equations = []            # I will store reaction rate equations as sympy equations in this list

    reaction_rate_equations_dict = {}       # The dictionary will store reaction rate equations mapped to the variable

    bc_equations = {}                       # For boundary conditions, we willl construct a virtual reaction. So we nned to construct an equation for this virtual reaction. in this dictionary, the compound name is mapped to the rate equation

    bc_equations_display = []               # If we want to display the equation, we need to display with the compound's name to identify it in equations.

    concentration_rate_equations = []       # Equations for concentration rates will be stored in this list




    # ------------ << Calling sorter function to sort the variables into their corresponding lists >> --------------
    variables, coefficients, reaction_rates, reaction_rate_constants, boundary_conditions = ces.variable_sorter( components )

    # --------------- << Since we build the equations from the coefficients and reaction rates given in the CellML file, if there are no reaction rates, we cannot build the equations >> --------------------
    if not reaction_rates:

        print("Since there is no reaction rates defined separately for the CellML file, the equations cannot be generated by this Python code at this moment")
        exit()

    for reaction_rate in reaction_rates:                    # Now we will go through each reaction to write the reaction rate equation for it
        
        rate = symbols( reaction_rate.name() )              # In CellML, a variable name is the name that the user has given to it like V, K and so on. So, we need to have them to write the similar equation as the user's one

        reaction_no = reaction_rate.id().split('_')[1]      # A sample id: "ra_r1", splitted by '_', first part shows the type of the variable and second part shows the reaction name

        reaction_reactants = {}                             # These two dictionaries will keep the reactants and products of this specific reaction mapped to their stoichiometric coefficients

        reaction_products = {}

        symbols_list = {}                                   # To write the equations in Sympy, all the variables must be converted to symbols of Sympy. This dictionary maps the variable to its Sympy symbol


        # --------- << At first, we need the reaction rate coefficients >> ------------
        # ------ { Now that we have the raction number, we need to find the reaction rate constant for this reaction. Therefore, we will go through all reaction rate constants and find the ones for this reaction } ------------
        for rate_constant in reaction_rate_constants:

            id = rate_constant.id()                         # Rate constant id sample: "rc_f_r1": splitted by '_', first part shows this a rate constant, second part is 'f' or 'r' which shows forward or reverse, respectively, the third part is the reaction which this rate constant belongs to

            if id.split('_')[2] == reaction_no:

                if id.split('_')[1] == 'f':
                    
                    forward_rate = symbols( rate_constant.name() )
                    forward_rate_value = rate_constant.initialValue()
                    
                elif id.split('_')[1] == 'r':

                    reverse_rate = symbols( rate_constant.name() )
                    reverse_rate_value = rate_constant.initialValue()


        # ------------- << Now, we need the participants with their stoichiometric coefficients. Hence, we look for the stoichiometric coefficients which have the value, the participant that this coefficient belongs nad the reaction >> ----------------
        for c_item in coefficients:

            id = c_item.id()                        # id is like this: 'co_12345_1' => first characters show that it is coefficient, second shows which participant this coefficient belongd, the thirs shows the reaction this participant participates by this coefficient

            if id.split('_')[2] == reaction_no:     # First, we need to find the participants in the reaction, so we check the reaction number for each participant and select them

                ChEBI = id.split('_')[1]

                coefficient = c_item.name()

                value = c_item.initialValue()

                for v_item in variables:            # Now, we look for the variable correspondant to this stoichiometric coefficient and we get its name
                    
                    if v_item.id().split('_')[1].split('-')[0] == ChEBI:

                        variable = v_item.name()    # This is the name user has given to the variable
                        break

                if int(value) < 0:                  # When the value for the stoichiometric coefficient is negative, it is considered as a reactant

                    reaction_reactants[variable] = abs( int(value) )

                elif int(value) > 0:                # When the value for the stoichiometric coefficient is positive, it is considered as a product

                    reaction_products[variable] = abs( int(value) )

                elif int(value) == 0:
                    print("The stoichiometric coefficient for {c} is set to zero which is wrong".format( c = coefficient ))
                    exit()

                symbols_list[variable] = symbols(variable)
                symbols_list[coefficient] = symbols(coefficient)

        # Now, we will start writing the right hand side of the equation
        # First part of right hand side is the forward reaction
        rhs_f = forward_rate
        rhs_f = rhs_f.subs( forward_rate, forward_rate_value )  # Since we need the values for the known variables to solve the equation, we replace the values

        for item in reaction_reactants:

            rhs_f = rhs_f * ( symbols_list[item] ** reaction_reactants[item] )

        try: 
        
            reverse_rate                                                        # At first, I check to see if there is a reverse rate for the reaction, if not the error can be catched and handled

            rhs_r = reverse_rate
            rhs_r = rhs_r.subs( reverse_rate, reverse_rate_value )

            for item in reaction_products:

                rhs_r = rhs_r * ( symbols_list[item] ** reaction_products[item] )

            reaction_rate_equations_dict[reaction_rate.name()] = rhs_f - rhs_r
            reaction_rate_equations.append( Eq(rate,rhs_f-rhs_r) )

        except:                                                                  # If there is not a reverse rate, the right hand side written for the forward rate is considered as the reaction rate for the reation rate variable we were handling

            reaction_rate_equations_dict[reaction_rate.name()] = rhs_f
            reaction_rate_equations.append( Eq(rate,rhs_f) )

    # ------- << Since sometimes I don't want to print out the equations, I have defined a printing function to control the output >> -------------
    if printing == 'on' or printing =='On' or printing == 'ON':

        printer( reaction_rate_equations, 'Rate equations of reactions' )


    
    # -------------------- << Constructing the virtual compounds and reaction for the boundary conditions >> ----------------------
    for bc in boundary_conditions:

        bc_name = bc.name()                                     # For each boundary condition, I will assign a name to distinguish from each other

        bc_chebi = bc.id().split('_')[1].split('.')[0]

        # --------- { Now I want to get the name of the compound, it can be a } --------
        if ces.all_digits( bc_chebi ):                          # if the chebi code aprt of the id is all digits, so it is considered as the chebi code, otherwise it shold be the compound name and composition given by the user

            compound, _ = chf.chebi_comp_parser( bc_chebi )

        else:

            compound = bc_chebi.split('-')[0]



        bc_value = bc.initialValue()                            # The value of the boundary condition is stored in a variable

        bc_display_name = 'v_' + compound                       # The name of the boundary condition to be displayed is composed of 'V' showing flow and the compound's name

        lhs_display = symbols( bc_display_name )

        lhs = symbols( bc_name )

        rhs = float( bc_value )

        bc_equations_display.append( Eq(lhs_display,rhs) )

        bc_equations[bc_name] = rhs

    if printing == 'on' or printing == 'On' or printing == 'ON':

        printer( bc_equations_display, 'Boundary conditions' )





    # ------------- << Here, I will write the concentration rate equations for the compounds in the reactions >> --------------------
    # ------------------------ { I need to check variables and write concentration rate for each } ----------------------------------

    for v_item in variables:

        r_symbols = {}                                  # This dictionary maps the compound to the corresponding Sympy symbols of them to write the equations

        id = v_item.id()                                # id of the variable

        ChEBI = id.split('_')[1].split('-')[0]          # Variable chebi code or name is the second in the id

        variable_name = v_item.name()                   # The name of the variable in CellML which user has written

        r_symbols[variable_name] = symbols( variable_name )

        constituents = {}                               # This dictionary maps the reaction rate to its stoichiometric coefficent for each compound. Then, I will call the items in this dictionary one by one ad multiply the key ot its value to construct the equation


        for c_item in coefficients:

            c_id = c_item.id()                                  # id of the coefficient

            c_chebi = c_id.split('_')[1]                        # Chebi code is the second part of the id split by '_'

            if c_chebi == ChEBI:                                # ChEBI is the compound's chebi code while c_chebi is the coefficient's chebi code. So we match both to wee if the coefficient belongs to this compound

                reaction_no = c_id.split('_')[2]                # If the coeffcient is for this compound, then we need to find the reaction in which this coeffcient is multiplied to this compound since a compound can participate in different reactions

                reaction_rate_coefficient = c_item.name()       # The coefficent has a name in CellML, so we try to get that name

                r_symbols[ reaction_rate_coefficient ] = symbols( reaction_rate_coefficient )

                # --> { To construct the rate of concentration for a compound, stoichiometric coeffcients will be multiplied to the reaction rates in which the compound participates }
                for r_item in reaction_rates:

                    if r_item.id().split('_')[1] == reaction_no:

                        reaction_rate = r_item.name()

                        r_symbols[ reaction_rate ] = symbols( reaction_rate )

                        break

                constituents[reaction_rate] = reaction_rate_coefficient


        # ********************************************************************************************************************************************
        # ----------------------- { Now I will check to see if there is any boundary condition defined for this compound } ----------------------------

        bc_list = []                                            # This list will store the boundary conditions defined for this compound

        for bc in boundary_conditions:

            bc_id = bc.id()                                     # In the list of boundary conditions, I will check to see if there is any boundary condition for this compound. So I need id of the boundary conditions

            compound = bc_id.split('_')[1].split('.')[0]        # Here I get the compound name or chebi code

            if compound == ChEBI:                               # As defined previously, ChEBI is the chebi code for the compound under investigation and compound is the chebi code or name for the ones in boundary conditions list

                bc_list.append( symbols( bc.name() ) )



        t = symbols('t')                                        # Sympy variable for time

        x = Function( r_symbols[variable_name] )(t)                  # Constructing the left hand side of the equation which is derivative of the compound

        lhs = x.diff(t)                                         # Putting the derivative into the left hand side of the equation

        rhs = Add()                                             # Creating an empty right hand side

        # As mentioned before, I call the items in 'constituents" dictionary and create the right hand side of the equation
        for item in constituents:

            rhs += r_symbols[item] * r_symbols[constituents[item]]

        # Then I add boundary conditions if there is any
        for item in bc_list:

            rhs += item


        # And finally I store all of the in the list of concentration rate equations list
        concentration_rate_equations.append(Eq(lhs,rhs))


    if printing == 'on' or printing == 'On' or printing == 'ON':

        printer( concentration_rate_equations, 'Concentration rate equations' )


    return reaction_rate_equations_dict, bc_equations






##########################################################################################

# ___________________________ Auxiliary Functions _______________________________________#

# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ #


def printer( equations, description ):

    if equations:

        # Initialize colorama
        init(autoreset=True)
        
        print( Fore.YELLOW + "\n {d} are as below: \n                \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193".format(d=description) )

        for equation in equations:

                print( Style.BRIGHT + Fore.RED + "{c}".format( c = equation.lhs ), end='')
                print( Style.BRIGHT + " = ", end='')
                print( Style.BRIGHT + Fore.MAGENTA + "{rh}".format( rh = equation.rhs ).rstrip('0') )

        print("**********************************************************************")