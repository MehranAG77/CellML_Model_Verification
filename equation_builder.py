# =============================================================================
# importing external packages
from sympy import symbols, Eq, simplify, Function, Add, solve
#from libcellml import Parser, Printer, Validator, cellmlElementTypeAsString
from colorama import Fore, Back, Style, init
import os


# Importing internal packages
from utilities import print_model
import chebi_fetch as chf
import compound_element_sorter as ces


def equation_builder( components, printing = 'off' ):

    '''
    This function takes the components and creates reaction rate equations and concentration rate equations for the reactions and compounds, respectively
    The function can display the reaction rate, concentration rate, and boundary condition equations
    But the function returns reaction rate equations and the boundary conditions to be used in constructing the concentration rate equations being created from the stoichiometric matrix
    There is an equation printing option which can be turned on if needed
    '''

    reaction_rate_equations = []            # I will store reaction rate equations as sympy equations in this list

    reaction_rate_equations_dict = {}       # The dictionary will store reaction rate equations mapped to the variable

    bc_equations = {}                       # For boundary conditions, we willl construct a virtual reaction. So we nned to construct an equation for this virtual reaction. in this dictionary, the compound name is mapped to the rate equation

    bc_equations_display = []               # If we want to display the equation, we need to display with the compound's name to identify it in equations.

    concentration_rate_equations = []       # Equations for concentration rates will be stored in this list

    general_equations = {}                  # This dictionary will store the equations for the variables without an initial value, the key value is the no initial value variable, and the value is the equation for it. This dictionary will be used in the ODE solver

    equations_display = []                  # The equations to be displayed on the screen

    # ------------ << Calling sorter function to sort the variables into their corresponding lists >> --------------
    variables, coefficients, reaction_rates, reaction_rate_constants, boundary_conditions, equation_variables = ces.variable_sorter( components )

    # variables => This list contains the concentration variables of compounds in cellml file [In CellML file]
    # coefficients => The difference between variables and coefficients is identified by the first part of their id which is like "va_12345_r1", first part indicates that this parameter is a variable
    # reaction_rates => This list contains all the rate variables (classes) for all equations that are in the model
    # reaction_rate_constants => This list contains the rate constants (classes) that are in the model
    # boundary_conditions => This list stores the boundary condition variables (classes) defined by the user

    # --------------- << Since we build the equations from the coefficients and reaction rates given in the CellML file, if there are no reaction rates, we cannot build the equations >> --------------------
    if not reaction_rates:

        command = 'cls' if os.name == 'nt' else 'clear'
        os.system(command)

        # Initialize colorama
        init(autoreset=True)
    
        print( Style.BRIGHT + Fore.RED + "Since there is no reaction rates defined separately for the CellML file, the equations cannot be generated by this Python code at this moment\n\n" )
        exit()


    '''
    *********************************************************************************************************************************************
    
    There are situations that some concentration variables are found from another equation which is a conservation equation.
    To create the equation for the corresponding variable, I have assigned IDs to variables which form an equation together.
    Now, I am going to create those equations by reading the IDs, identifying the variables in the same equation and grouping them in a list.
    Then, I'll create the equation using the created list.

    *********************************************************************************************************************************************
    '''
    # At first, I'll search for the variables with no initial value and store their IDs in a Python variable

    target_equations = []                           # This list will store the equation IDs of the variables with no initial value

    # At first step, I'll search for the concentration variables that don't have initial values. It indicates that I need to find another way (an equation) to get the value
    for c_variable in variables:

        # Checking if there is not initial vlaue for the variable in variables list
        if not c_variable.initialValue():

            cv_id = c_variable.id()

            # If not, then I'll store the equation ID in the list of target equations
            target_equations.append( cv_id.split('_')[2].split('.')[0] )
    
    # Then, I'll write the equations by checking the shared equation IDs for the variables
    for equation_id in target_equations:

        equation_terms = []                         # This list will store the equation terms for each equation that is being generated

        rhs = 0                                     # Empty right hand side

        lhs = 0                                     # Empty left hand side


        # There are two types of concentration variables in the CellML file, the ones which are a fixed initial value, and the ones which are the same type as the concentration variable that we have
        # Therefore, at first I check the concentration variables and start forming the equations
        for c_variable in variables:
            
            # If the ID has 3 sections, so it is a part of an equation
            if len( c_variable.id().split('_') ) > 2 :

                attending_equations = c_variable.id().split('_')[2].split('-')      # Some compounds can be in more than one conservation equation, so it is defined by the a dash ,'-', in the third part of the ID
                                                                                    # and we need to go through all those equation IDs and check for the compound participating in the equation being generated

                for ids in attending_equations:

                    cv_eq_id = ids.split('.')[0] 

                    # If the equation ID of the concentration variable is the same as equation ID, I will add it to the equations terms
                    if cv_eq_id == equation_id:

                        equation_terms.append( c_variable )

                        # In the ID of the CellML variables, I have added 'l' or 'r' to show if the term is on the left or right hand side of the equation. Assuming all terms are positive and just lie on the left or right hand side, I don't need to add another variable as sign coeeficient
                        if ids.split('.')[1] == 'l':

                            lhs += symbols( c_variable.name() )

                        elif ids.split('.')[1] == 'r':

                            rhs += symbols( c_variable.name() )

        # Other concentration variables which are not considered as concentration variables
        for ev_variable in equation_variables:

            ev_id = ev_variable.id().split('_')[1].split('.')[0]

            if ev_id == equation_id:

                equation_terms.append( ev_variable )

                if ev_variable.id().split('_')[1].split('.')[1] == 'l':

                    variable_to_add = symbols( ev_variable.name() )

                    lhs += variable_to_add
                    
                    try:

                        lhs = lhs.subs( variable_to_add, float(ev_variable.initialValue()) )

                    except ValueError:
                        
                        command = 'cls' if os.name == 'nt' else 'clear'
                        os.system(command)

                        # Initialize colorama
                        init(autoreset=True)

                        print( Style.BRIGHT + Fore.RED + "There is no initial value defined for {E}\n\n\n\n".format( E = variable_to_add ) )
                        exit()

                elif ev_variable.id().split('_')[1].split('.')[1] == 'r':

                    variable_to_add = symbols( ev_variable.name() )

                    rhs += variable_to_add

                    try:

                        rhs = rhs.subs( variable_to_add, float(ev_variable.initialValue()) )

                    except ValueError:
                        
                        command = 'cls' if os.name == 'nt' else 'clear'
                        os.system(command)

                        # Initialize colorama
                        init(autoreset=True)

                        print( Style.BRIGHT + Fore.RED + "There is no initial value defined for {E}\n\n\n\n".format( E = variable_to_add ) )
                        exit()


        # Now, I make the equation in Sympy with left and right hand sides
        equation = Eq( lhs, rhs )

        # Now that I have the equations including no initial value terms, I  will rearrange them to represent the equation as a function of the variable with no inital value
        for equation_term in equation_terms:

            if not equation_term.initialValue():

                main_variable = equation_term.name()

                rearranged_rhs = solve( equation, main_variable )

                rearranged_lhs = symbols( main_variable )

                rearrnaged_equation = Eq( rearranged_lhs, rearranged_rhs[0] )

                general_equations[ main_variable ] = rearranged_rhs[0]

                equations_display.append( rearrnaged_equation )


    if printing == 'on' or printing == 'On' or printing == 'ON':

        printer( equations_display, 'The simple equations for non-initial value compounds' )



    '''
    ************************************************************************************************************
    The equations for reaction rates are written
    ************************************************************************************************************
    '''

    for reaction_rate in reaction_rates:                    # Now we will go through each reaction to write the reaction rate equation for it
        
        rate = symbols( reaction_rate.name() )              # In CellML, a variable name is the name that the user has given to it like V, K and so on. So, we need to have them to write the similar equation as the user's one

        reaction_no = reaction_rate.id().split('_')[1]      # A sample id: "ra_r1", splitted by '_', first part shows the type of the variable and second part shows the reaction name

        reaction_reactants = {}                             # These two dictionaries will keep the reactants and products of this specific reaction mapped to their stoichiometric coefficients

        reaction_products = {}

        symbols_list = {}                                   # To write the equations in Sympy, all the variables must be converted to symbols of Sympy. This dictionary maps the variable to its Sympy symbol

        

        # --------- << At first, we need the reaction rate coefficients >> ------------
        # ------ { Now that we have the raction number, we need to find the reaction rate constant for this reaction. Therefore, we will go through all reaction rate constants and find the ones for this reaction } ------------
        for rate_constant in reaction_rate_constants:

            id = rate_constant.id()                         # Rate constant id sample: "rc_f_r1": splitted by '_', first part shows this a rate constant, second part is 'f' or 'r' which shows forward or reverse, respectively, the third part is the reaction which this rate constant belongs to

            if id.split('_')[2] == reaction_no:

                if id.split('_')[1] == 'f':
                    
                    forward_rate = symbols( rate_constant.name() )
                    forward_rate_value = rate_constant.initialValue()
                    
                elif id.split('_')[1] == 'r':

                    reverse_rate = symbols( rate_constant.name() )
                    reverse_rate_value = rate_constant.initialValue()

        
        # Now, we will start writing the right hand side of the equation
        # First part of right hand side is the forward reaction
        # rhs_f = forward_rate
        # rhs_f = rhs_f.subs( forward_rate, forward_rate_value )  # Since we need the values for the known variables to solve the equation, we replace the values

        try: 
        
            reverse_rate                                                        # At first, I check to see if there is a reverse rate for the reaction, if not the error can be catched and handled

            rhs_f = forward_rate
            rhs_f = rhs_f.subs( forward_rate, forward_rate_value )  # Since we need the values for the known variables to solve the equation, we replace the values

            rhs_r = reverse_rate
            rhs_r = rhs_r.subs( reverse_rate, reverse_rate_value )

        except:

            rhs_f = forward_rate
            rhs_f = rhs_f.subs( forward_rate, forward_rate_value )  # Since we need the values for the known variables to solve the equation, we replace the values


        # ------------- << Now, we need the participants with their stoichiometric coefficients. Hence, we look for the stoichiometric coefficients which have the value, the participant that this coefficient belongs nad the reaction >> ----------------
        for c_item in coefficients:

            id = c_item.id()                        # id is like this: 'co_12345_1' => first characters show that it is coefficient, second shows which participant this coefficient belongd, the thirs shows the reaction this participant participates by this coefficient

            if id.split('_')[2] == reaction_no:     # First, we need to find the participants in the reaction, so we check the reaction number for each participant and select them

                ChEBI = id.split('_')[1]

                coefficient = c_item.name()

                value = c_item.initialValue()

                for v_item in variables:            # Now, we look for the variable correspondant to this stoichiometric coefficient and we get its name
                    
                    if v_item.id().split('_')[1].split('-')[0] == ChEBI:

                        variable = v_item.name()    # This is the name user has given to the variable
                        break
                
                try:
                    
                    reverse_rate

                    if int(value) < 0:                  # When the value for the stoichiometric coefficient is negative, it is considered as a reactant

                        if not v_item.initialValue():

                            rhs_f = rhs_f * ( ( general_equations[variable] ) ** abs( int(value) )  )

                        else:
                            
                            rhs_f = rhs_f * ( ( symbols( variable ) ) ** abs( int(value) ) )

                    elif int(value) > 0:                # When the value for the stoichiometric coefficient is positive, it is considered as a product

                        if not v_item.initialValue():
                            
                            rhs_r = rhs_r * ( ( general_equations[variable] ) ** abs( int(value) )  )

                        else:
                            
                            rhs_r = rhs_r * ( ( symbols( variable ) ) ** abs( int(value) ) )

                    elif int(value) == 0:
                        print("The stoichiometric coefficient for {c} is set to zero which is wrong".format( c = coefficient ))
                        exit()

                except:

                    if int(value) < 0:                  # When the value for the stoichiometric coefficient is negative, it is considered as a reactant

                        if not v_item.initialValue():

                            rhs_f = rhs_f * ( ( general_equations[variable] ) ** abs( int(value) )  )

                        else:
                            
                            rhs_f = rhs_f * ( ( symbols( variable ) ) ** abs( int(value) ) )

                    elif int(value) == 0:
                        print("The stoichiometric coefficient for {c} is set to zero which is wrong".format( c = coefficient ))
                        exit()

        #         symbols_list[variable] = symbols(variable)
        #         symbols_list[coefficient] = symbols(coefficient)

        # # # Now, we will start writing the right hand side of the equation
        # # # First part of right hand side is the forward reaction
        # # rhs_f = forward_rate
        # # rhs_f = rhs_f.subs( forward_rate, forward_rate_value )  # Since we need the values for the known variables to solve the equation, we replace the values

        # # for item in reaction_reactants:

        # #     rhs_f = rhs_f * ( symbols_list[item] ** reaction_reactants[item] )

        # try: 
        
        #     # reverse_rate                                                        # At first, I check to see if there is a reverse rate for the reaction, if not the error can be catched and handled

        #     # rhs_r = reverse_rate
        #     # rhs_r = rhs_r.subs( reverse_rate, reverse_rate_value )

        #     # for item in reaction_products:

        #     #     rhs_r = rhs_r * ( symbols_list[item] ** reaction_products[item] )

        #     reaction_rate_equations_dict[reaction_rate.name()] = rhs_f - rhs_r
        #     reaction_rate_equations.append( Eq(rate,rhs_f-rhs_r) )

        # except:                                                                  # If there is not a reverse rate, the right hand side written for the forward rate is considered as the reaction rate for the reation rate variable we were handling

        reaction_rate_equations_dict[reaction_rate.name()] = rhs_f
        reaction_rate_equations.append( Eq(rate,rhs_f) )

    # ------- << Since sometimes I don't want to print out the equations, I have defined a printing function to control the output >> -------------
    if printing == 'on' or printing =='On' or printing == 'ON':

        printer( reaction_rate_equations, 'Rate equations of reactions' )


    
    # -------------------- << Constructing the virtual compounds and reaction for the boundary conditions >> ----------------------
    for bc in boundary_conditions:

        bc_name = bc.name()                                     # For each boundary condition, I will assign a name to distinguish from each other

        bc_chebi = bc.id().split('_')[1].split('.')[0]

        # --------- { Now I want to get the name of the compound, it can be a } --------
        if ces.all_digits( bc_chebi ):                          # if the chebi code aprt of the id is all digits, so it is considered as the chebi code, otherwise it shold be the compound name and composition given by the user

            compound, _ = chf.chebi_comp_parser( bc_chebi )

        else:

            compound = bc_chebi.split('-')[0]



        bc_value = bc.initialValue()                            # The value of the boundary condition is stored in a variable

        bc_display_name = 'v_' + compound                       # The name of the boundary condition to be displayed is composed of 'V' showing flow and the compound's name

        lhs_display = symbols( bc_display_name )

        lhs = symbols( bc_name )

        rhs = float( bc_value )

        bc_equations_display.append( Eq(lhs_display,rhs) )

        bc_equations[bc_name] = rhs

    if printing == 'on' or printing == 'On' or printing == 'ON':

        printer( bc_equations_display, 'Boundary conditions' )





    # ------------- << Here, I will write the concentration rate equations for the compounds in the reactions >> --------------------
    # ------------------------ { I need to check variables and write concentration rate for each } ----------------------------------

    for v_item in variables:

        r_symbols = {}                                  # This dictionary maps the compound to the corresponding Sympy symbols of them to write the equations

        id = v_item.id()                                # id of the variable

        ChEBI = id.split('_')[1].split('-')[0]          # Variable chebi code or name is the second in the id

        variable_name = v_item.name()                   # The name of the variable in CellML which user has written

        r_symbols[variable_name] = symbols( variable_name )

        constituents = {}                               # This dictionary maps the reaction rate to its stoichiometric coefficent for each compound. Then, I will call the items in this dictionary one by one ad multiply the key ot its value to construct the equation


        for c_item in coefficients:

            c_id = c_item.id()                                  # id of the coefficient

            c_chebi = c_id.split('_')[1]                        # Chebi code is the second part of the id split by '_'

            if c_chebi == ChEBI:                                # ChEBI is the compound's chebi code while c_chebi is the coefficient's chebi code. So we match both to wee if the coefficient belongs to this compound

                reaction_no = c_id.split('_')[2]                # If the coeffcient is for this compound, then we need to find the reaction in which this coeffcient is multiplied to this compound since a compound can participate in different reactions

                reaction_rate_coefficient = c_item.name()       # The coefficent has a name in CellML, so we try to get that name

                r_symbols[ reaction_rate_coefficient ] = symbols( reaction_rate_coefficient )

                # --> { To construct the rate of concentration for a compound, stoichiometric coeffcients will be multiplied to the reaction rates in which the compound participates }
                for r_item in reaction_rates:

                    if r_item.id().split('_')[1] == reaction_no:

                        reaction_rate = r_item.name()

                        r_symbols[ reaction_rate ] = symbols( reaction_rate )

                        break

                constituents[reaction_rate] = reaction_rate_coefficient


        # ********************************************************************************************************************************************
        # ----------------------- { Now I will check to see if there is any boundary condition defined for this compound } ----------------------------

        bc_list = []                                            # This list will store the boundary conditions defined for this compound

        for bc in boundary_conditions:

            bc_id = bc.id()                                     # In the list of boundary conditions, I will check to see if there is any boundary condition for this compound. So I need id of the boundary conditions

            compound = bc_id.split('_')[1].split('.')[0]        # Here I get the compound name or chebi code

            if compound == ChEBI:                               # As defined previously, ChEBI is the chebi code for the compound under investigation and compound is the chebi code or name for the ones in boundary conditions list

                bc_list.append( symbols( bc.name() ) )



        t = symbols('t')                                        # Sympy variable for time

        x = Function( r_symbols[variable_name] )(t)                  # Constructing the left hand side of the equation which is derivative of the compound

        lhs = x.diff(t)                                         # Putting the derivative into the left hand side of the equation

        rhs = Add()                                             # Creating an empty right hand side

        # As mentioned before, I call the items in 'constituents" dictionary and create the right hand side of the equation
        for item in constituents:

            rhs += r_symbols[item] * r_symbols[constituents[item]]

        # Then I add boundary conditions if there is any
        for item in bc_list:

            rhs += item


        # And finally I store all of the in the list of concentration rate equations list
        concentration_rate_equations.append(Eq(lhs,rhs))


    if printing == 'on' or printing == 'On' or printing == 'ON':

        printer( concentration_rate_equations, 'Concentration rate equations' )





    return reaction_rate_equations_dict, bc_equations, general_equations

















##########################################################################################

# ___________________________ Auxiliary Functions _______________________________________#

# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\ #


def printer( equations, description ):

    if equations:

        # Initialize colorama
        init(autoreset=True)
        
        print( Fore.YELLOW + "\n {d} are as below: \n                \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193".format(d=description) )

        for equation in equations:

                print( Style.BRIGHT + Fore.RED + "{c}".format( c = equation.lhs ), end='')
                print( Style.BRIGHT + " = ", end='')
                print( Style.BRIGHT + Fore.MAGENTA + "{rh}".format( rh = equation.rhs ).rstrip('0') )

        print("**********************************************************************")